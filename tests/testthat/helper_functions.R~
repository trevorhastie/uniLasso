enlist <- function (...) {
    result <- list(...)
    if ((nargs() == 1) & is.character(n <- result[[1]])) {
        result <- as.list(seq(n))
        names(result) <- n
        for (i in n) result[[i]] <- get(i)
    }
    else {
        n <- sys.call()
        n <- as.character(n)[-1]
        if (!is.null(n2 <- names(result))) {
            which <- n2 != ""
            n[which] <- n2[which]
        }
        names(result) <- n
    }
    result
}

MakeYMat  <-  function(y) {
    ymat <- matrix(0, nrow=length(y), ncol=length(unique(y)))
    for(i in 1:ncol(ymat)) ymat[y==i,i] <- 1
    return(ymat)
}

norm2  <- function(x, ...) {
    Matrix::norm(x, type = "2", ...)
}

kkt.multnet <- function(x,y,standardize=TRUE,intercept=TRUE,which.lambda=15,offset=FALSE,digits=7,type.multinomial="ungrouped",...) {

    family="multinomial"
    kpass=function(mat)(sum(apply(mat,1,prod))==0)&all(mat[,2]<=0)
    if(missing(offset))
        fit=glmnet(x,y,intercept=intercept,standardize=standardize,family=family,type.multinomial=type.multinomial,...)
    else
        fit=glmnet(x,y,intercept=intercept,standardize=standardize,family=family,type.multinomial=type.multinomial,offset=offset,...)
    n = nrow(x)
    sdj=function(x)drop(sqrt(var(x)*(length(x)-1)/length(x)))
    if(standardize)sdx=apply(x,2,sdj)else sdx=rep(1,ncol(x))
    xsd=scale(x,intercept,sdx)
    lambda0=fit$lambda[which.lambda]
    ## print(coef(fit,s=lambda0))
    if(missing(offset))  pred=predict(fit,x,s=lambda0,type="response")
    else  pred=predict(fit,x,s=lambda0,type="response",newoffset=offset)
    resid=y-drop(pred)
    cmat=sapply(coef(fit,s=lambda0),as.matrix)
    if(type.multinomial=="ungrouped"){
        kmat=round(abs(t(xsd)%*%resid/n)-lambda0,digits)
        mat=array(rbind(cmat,rbind(-!intercept,kmat)),c(nrow(cmat),2,ncol(cmat)))
        kkt.pass= apply(mat,3,kpass)
    }
    else{
        nrm=apply(cmat,1,norm2)
        gmat=t(xsd)%*%resid/n
        gnorm=apply(gmat,1,norm2)
        kvec=round(gnorm-lambda0,digits)
        mat=cbind(nrm,c(-!intercept,kvec))
        kkt.pass=kpass(mat)
    }
    attr(mat,"kkt.pass")=kkt.pass
    mat
}


kkt.glmnet <- function(x,y,standardize=TRUE,intercept=TRUE,which.lambda=15,family="gaussian",offset=FALSE,digits=7,...) {
    if(missing(offset))
        fit=glmnet(x,y,intercept=intercept,standardize=standardize,family=family,...)
    else
        fit=glmnet(x,y,intercept=intercept,standardize=standardize,family=family,offset=offset,...)
    n = nrow(x)
    sdj=function(x)drop(sqrt(var(x)*(length(x)-1)/length(x)))
    if(standardize)sdx=apply(x,2,sdj)else sdx=rep(1,ncol(x))
    xsd=scale(x,intercept,sdx)
    if(family=="gaussian"){sdy=sdj(y);ysd=y/sdy}  else {sdy=1;ysd=y}
    lambda0=fit$lambda[which.lambda]
    ## print(coef(fit,s=lambda0))
    if(missing(offset))  pred=predict(fit,x,s=lambda0,type="response")/sdy
    else  pred=predict(fit,x,s=lambda0,type="response",newoffset=offset)/sdy

    resid=ysd-pred
    mat=cbind(as.matrix(coef(fit,s=lambda0)),rbind(-!intercept,round(abs(t(xsd)%*%resid/n)-lambda0/sdy,digits)))
    kkt.pass= (sum(apply(mat,1,prod))==0)&all(mat[,2]<=0)
    attr(kkt.pass,"kkt.mat")=mat
    kkt.pass
}

sysinfo  <- Sys.info()
